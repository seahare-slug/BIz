함수는 객체에 의해서 실행되는 건지
객체 자체들을 컨트롤 할 때 사용되는 건지
프로그램 전반적인 부분을 컨트롤 하는건지에 따라서

그 함수가 객체의 함수가 될지, static으로서 전역함수로 클래스의 함수가 될지 정해짐

new 키워드는 동적 바인딩(블럭 스코프가 아닌 가비지컬랙터 작동할 때까지 유효)
일반적인 정적 바인딩은 블록스코프
heap은 주소 관리가 안 돼서 가비지컬렉터가 관리

정적 바인딩: 메모리누수 없음, 속도가 빠름
동적 바인딩: 수정이 용이함

상속(isA구조)보다는 자식이 부모 객체를 가지는(hasA) 구조와 인터페이스를 통해 속성을 부여받는 구조가 트랜드
-> 다이아몬드 상속의 문제점 때문에 Java, C#에서는 다중상속이 제한됨
-> 반면에 인터페이스는 다중상속이 됨(필드가 없이 메소드만 상속을 해주고 다이아몬드 상속의 문제점인 상속 내용을 누구껄 따라야하는지 모르는 경우에 메서드는 재정의를 해버리면 되기 때문에)

mutable - immutable
이렇게 데이터의 값이 바뀌었을 때 주소값을 새로 할당할지의 문제는 python 에서는 데이터 타입에 따라 기본적으로 속성이 제공되어 있었지만 C#에서는 기본적으로 명시없이는 얕은 복사의 형태(주소값을 재할당 하지 않음)로 수행되기 때문에 `clone`이라는 메서드를 통해서 새로운 메모리에 할당해줄 수 있음.